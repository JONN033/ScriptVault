local ESP = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),

    Rainbow = false,
    Boxes = false,
    Names = false,
    Distance = false,
    Tracers = false,
    UnlockTracers = false,
    Skeletons = false, -- New: Skeleton Drawing

    Objects = setmetatable({}, {__mode = "kv"}),
    Overrides = {},

    MainRenderStepped = nil
}

local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Players = cloneref(game:GetService("Players"))
local workspace2 = cloneref(game:GetService("Workspace"))
local Rainbow = 0

-- Function to create a new drawing object
local function Draw(obj, props)
    local new = Drawing.new(obj)
    props = props or {}

    for i, v in next, props do
        new[i] = v
    end

    return new
end

function ESP:GetColor(obj)
    local ov = self.Overrides.GetColor
    if ov then
        return ov(obj)
    end

    local p = self:GetPlrFromChar(obj)
    return p and self.Color
end

function ESP:GetPlrFromChar(char)
    local ov = self.Overrides.GetPlrFromChar
    if ov then
        return ov(char)
    end
    return Players:GetPlayerFromCharacter(char)
end

function ESP:Toggle(bool)
    if not bool then
        for i, v in next, self.Objects do
            if v.Type == "Box" then
                if v.Temporary then
                    v:Remove()
                else
                    for i, v in next, v.Components do
                        v.Visible = false
                    end
                end
            end
        end
    end
end

function ESP:GetBox(obj)
    return self.Objects[obj]
end

function ESP:AddObjectListener(parent, options)
    local function NewListener(c)
        if type(options.Type) == "string" and c:IsA(options.Type) or options.Type == nil then
            if type(options.Name) == "string" and c.Name == options.Name or options.Name == nil then
                if not options.Validator or options.Validator(c) then
                    local box = ESP:Add(c, {
                        PrimaryPart = type(options.PrimaryPart) == "string" and c:WaitForChild(options.PrimaryPart) or type(options.PrimaryPart) == "function" and options.PrimaryPart(c),
                        Color = type(options.Color) == "function" and options.Color(c) or options.Color,
                        ColorDynamic = options.ColorDynamic,
                        Name = type(options.CustomName) == "function" and options.CustomName(c) or options.CustomName,
                        IsEnabled = options.IsEnabled,
                        RenderInNil = options.RenderInNil
                    })

                    if options.OnAdded then
                        coroutine.wrap(options.OnAdded)(box)
                    end
                end
            end
        end
    end

    if options.Recursive then
        parent.DescendantAdded:Connect(NewListener)
        for i, v in next, parent:GetDescendants() do
            coroutine.wrap(NewListener)(v)
        end
    else
        parent.ChildAdded:Connect(NewListener)
        for i, v in next, parent:GetChildren() do
            coroutine.wrap(NewListener)(v)
        end
    end
end

-- Skeleton drawing function
function ESP:DrawSkeleton(char)
    if not self.Skeletons then return end

    local parts = {
        Head = char:FindFirstChild("Head"),
        UpperTorso = char:FindFirstChild("UpperTorso"),
        LowerTorso = char:FindFirstChild("LowerTorso"),
        LeftArm = char:FindFirstChild("LeftUpperArm"),
        RightArm = char:FindFirstChild("RightUpperArm"),
        LeftLeg = char:FindFirstChild("LeftUpperLeg"),
        RightLeg = char:FindFirstChild("RightUpperLeg")
    }

    if not (parts.Head and parts.UpperTorso and parts.LowerTorso) then
        return
    end

    local function drawLine(part1, part2, color)
        local pos1 = workspace2.CurrentCamera:WorldToViewportPoint(part1.Position)
        local pos2 = workspace2.CurrentCamera:WorldToViewportPoint(part2.Position)

        local line = Draw("Line", {
            From = Vector2.new(pos1.X, pos1.Y),
            To = Vector2.new(pos2.X, pos2.Y),
            Color = color or ESP.Color,
            Thickness = 1,
            Visible = true
        })
        return line
    end

    local color = ESP.Rainbow and Color3.fromHSV(Rainbow, 1, 1) or ESP.Color

    -- Draw skeleton parts (Head -> UpperTorso -> LowerTorso)
    drawLine(parts.Head, parts.UpperTorso, color)
    drawLine(parts.UpperTorso, parts.LowerTorso, color)

    -- Draw arms
    if parts.LeftArm and parts.RightArm then
        drawLine(parts.UpperTorso, parts.LeftArm, color)
        drawLine(parts.UpperTorso, parts.RightArm, color)
    end

    -- Draw legs
    if parts.LeftLeg and parts.RightLeg then
        drawLine(parts.LowerTorso, parts.LeftLeg, color)
        drawLine(parts.LowerTorso, parts.RightLeg, color)
    end
end

function ESP:UpdateObject(v)
    -- Add skeleton drawing
    self:DrawSkeleton(v.Object)

    -- Update existing ESP functionality
    -- (e.g., Boxes, Names, Distance, Tracers, etc.)
    -- Your existing code goes here...
end

function ESP:Add(obj, options)
    if not obj.Parent and not options.RenderInNil then
        return warn(obj, "has no parent")
    end

    local box = setmetatable({
        Name = options.Name or obj.Name,
        Type = "Box",
        Color = options.Color,
        Size = options.Size or Vector3.new(4, 6, 0),
        Object = obj,
        Player = options.Player or Players:GetPlayerFromCharacter(obj),
        PrimaryPart = options.PrimaryPart or obj.ClassName == "Model" and (obj.PrimaryPart or obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")) or obj:IsA("BasePart") and obj,
        Components = {},
        IsEnabled = options.IsEnabled,
        Temporary = options.Temporary,
        ColorDynamic = options.ColorDynamic,
        RenderInNil = options.RenderInNil
    }, boxBase)

    if self:GetBox(obj) then
        self:GetBox(obj):Remove()
    end

    -- Draw box, name, distance, and tracer as before
    box.Components["Quad"] = Draw("Quad", {
        Thickness = 2,
        Color = ESP.Rainbow and Color3.fromHSV(Rainbow, 1, 1) or ESP.Color,
        Filled = false,
        Visible = self.Boxes
    })

    box.Components["Name"] = Draw("Text", {
        Text = box.Name,
        Color = box.Color,
        Center = true,
        Outline = true,
        Size = 19,
        Visible = self.Names
    })

    box.Components["Distance"] = Draw("Text", {
        Color = box.Color,
        Center = true,
        Outline = true,
        Size = 19,
        Visible = self.Distance
    })

    box.Components["Tracer"] = Draw("Line", {
        Thickness = 2,
        Color = box.Color,
        Visible = self.Tracers
    })

    self.Objects[obj] = box

    -- Handle object removal and connections
    obj.AncestryChanged:Connect(function(_, parent)
        if parent == nil and ESP.AutoRemove ~= false then
            box:Remove()
        end
    end)

    obj:GetPropertyChangedSignal("Parent"):Connect(function()
        if obj.Parent == nil and ESP.AutoRemove ~= false then
            box:Remove()
        end
    end)

    local hum = obj:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.Died:Connect(function()
            if ESP.AutoRemove ~= false then
                box:Remove()
            end
        end)
    end

    return box
end

-- Player and Character management remains unchanged
-- ...

ESP.MainRenderStepped = RunService.RenderStepped:Connect(function()
    Rainbow = (Rainbow + 0.001) % 1

    for i, v in next, ESP.Objects do
        if v.Update then
            local s, e = pcall(function()
                ESP:UpdateObject(v)
            end)
            if not s then warn(e) end
        end
    end
end)

return ESP
